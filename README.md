# State of the fried-egg project

Any questions? Oliver's internship is over but he is happy to answer questions (oflatt@gmail.com).

Fried egg is an egraph-based simplifier for TAC programs. It takes as input a program represented as a series of blocks with assignments to variables in them (see tests in `lin_inv.rs`). It outputs this same format, but tries to simplify each variable's right hand side value. Right now it very experimental, and it's not clear if it will
actually help simplify the query to Z3 or not.

Fried egg works by first inserting the program into the egraph, running math axioms on the egraph, then extracting the program back out. In an egraph, intermediate variables are bad (they make it hard to extract things back out), so we try to avoid them by keeping a side table of which variables correspond to eclasses in the egraph.

The math axioms are generated by our `ruler-evm` project, forked from `ruler`. Ruler figures out math axioms by enumerating things in the egraph and checking if they are true using Z3.
Rules should not be written by hand if possible.
See the list of axioms in `ruler-rules.json`.

Initially, each block uses completely independent variables. However, if we learn that a variable is the same for all parents of a block, then we can use it in the child block. See `full_program_2` in `lin_inv.rs` for an example.

Right now we only support two types: booleans and bv256. On the rust side, these are treated both as 256 unsigned integers. Booleans and bv256 values are separate types on the kotlin side, so we must extract things that will typecheck. To do this, the egraph keeps track of a best expression for both the boolean and bv256 types. We send the types of all variables over to rust so that it knows the types of variables.
When we get the program back on the kotlin side, we then re-infer what these types should be (the only tricky bit being that constants that are 0 or 1 could be either type).


## To-dos

- The regression tests in CI do not pass, there must be some sort of terrible unsoundness bug.
- When converting back on the kotlin side, full expressions need to be converted back to three-address form. I wrote `toCommands` in `TACExpr.kt` to do this, but it doesn't take into account sharing. If two separate expressions share some subpart, it makes two variables even though they are the same. Example:

```
a = (b + c) * d
x = (b + c) * (b + c)

Is translated to:
temp1 = b + c
a = temp1 + d
temp2 = b + c
temp3 = b + c
x = temp2 * temp3

When it could be:
temp1 = b + c
a = temp1 + d
x = temp1 * temp1
```

- We currently use `logical_equality` for small math simplifications, but we should really just send a small program with one expression in it to `lin_inv` instead and delete that file.
- We are missing boolean axioms like `(&& a 1) => a` because we don't distinguish between bools and bv256. We should generate boolean axioms using Ruler and then use them on boolean expressions (we can tell if something is a boolean by checking the operator or looking up the variable).
- Errors from the Rust process tend to disappear in CI, and I'm not sure if they show up from staging. Where are they going? See `RustBlaster.kt` for where we call `redirectError`, which redirects the stderr out to the current process.
- It would be cool to do partial evaluation / automatic inlining in the egraph when we simplify things. Though I'm not sure if it's worth the runtime cost.
Imagine we have a program:
```
Block1: x = 0

Block2: x = 2 * pi

Block3, with parents (Block1 and Block2): y = sin(x)
```
If we try inlining block1 and block2, we find that in both cases y = 0. But we will never find that the x in block1 is equal to the x in block2. (This is just an example, we don't actually support sin or real numbers.)



## Future project: Adapting to perform linear invariant inference

We would like to replace `PointerSimplification.kt` with fried-egg, since it could be much faster and find better simplifications.
The challenge is to not replace assignments that need to maintain a particular shape for other analysis.
In particular, byte array length computations are a problem. There is code that finds these computations in `AllocationAnalysis.kt`, but the PointerSimplification code does it's own ad-hoc thing using the invariants it found.

Besides detecting these cases, it should be a drop-in replacement because we first try to extract linear invariants on the rust side. Make sure to run the `EncoderAnalysisTest.kt` and the `DecoderAnalysisTest.kt`. If those pass the replacement worked.